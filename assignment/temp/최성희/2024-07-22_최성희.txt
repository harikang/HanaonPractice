# @
# 파이썬) 데코레이터: 꾸며주는 함수
    # 1. 함수데코레이터
        @데코레이터    #함수 바로 위에서 함수를 꾸며주고 있으므로 함수데코레이터
        def asdf():
            return a
    # 2. 클래스데코레이터: 클래스를 꾸며준다. -> 클래스의 메소드를 꾸며준다.
        ex: property

        class 클래스명:
          @데코레이터  #클래스에 속해있는 메소드를 꾸며주는 것이 클래스데코레이터.
          def __

            @property
            @field.setter
            @staticmethod
            ...

        #getter(메소드): 필드에 값을 가져오는 것
        #setter(메소드): 필드에 값을 주입하는 것



    # 파이썬에서 미리 만들어둔 데코레이터
    # 사용자데코레이터(직접 만들어 사용하는...)


# 자바) 어노테이션: 인터프리터나 컴파일러한테 명시적으로 알려준다.

----------------------------------

# 접근제한자: ~~~~~~~~~~ 파이썬은 없다?? 개발자가 알아서 ...
# 검증
# ? 값을 마음대로 바꾸면 안 된다

# 클래스
    # 값: 필드
    # 기능: 함수(메소드)


# lombok: 여러가지 @어노테이션을 제공하고 컴파일 과정에서 자동으로 개발자가 원하는 메소드를 생성/주입 방식으로 동작하는 라이브러리(프레임워크)

--------------------------------

# 프로그래밍은 기본적으로 객체 지향 프로그래밍 지원
    # 접근제한자
        public > protected > default(자기자신) > privated(가장 제한 되어있음)
    # 캡슐화: 통제
    # 다형성
    # 상속

---------------------------------

def trace(f):  # 호출할 함수를 매개변수로 받음
    def wrapper():
        print("함수가 호출되었습니다.")
        f()
        print("함수를 실행했습니다.")

    return wrapper()

# 다른 함수 혹은 다른 메소드를 꾸며준다

@trace
print("본체가 출력됩니다.")


-------------------------------

sixth_02.py

class Book:
    def __init__(self, raw_price):
        if raw_price < 0:
            raise ValueError("0보다 큰 값이 들어가야 합니다.")
        self.raw_price = raw_price
        self._discounts = 0

    def discount(self):
        return self._discounts



main.py

from Sec06_01.sixth_02 import Book


if __name__ == "__main__":
    책01 = Book(20000) #구체화된 객체인 인스턴스를 만들었다
    pp(책01.raw_price)
    pp(책01._discounts)
    dis = 책01.discount()
    pp(dis)

-----------------------------

# method overload -> overloading: 같은 이름의 메소드가 쓰이는 것
# method override -> overriding: 부모가 정의한 메소드를 상속받은 자식에서 재정의하는 것

--------------------------------

# 던더
# 속성(attribute): 값 value, property, field, 기능, (연관)함수, method(던더메소드, 사용자메소드)

# 선언

# constructor 생성자
# 할당

-------------------------------

class Page:
    book_title = 'Python Practice Book'
    def __init__(self, num, content): # 생성자
        self.num = num #인스턴스 변수
        self.content = content #인스턴스 변수
    def output(self): #인스턴스 메소드
        return f'{self.content}'

    # 클래스 메서드의 첫 번째 인수는 클래스 객체
    @classmethod
    # cls
    가변 위치 인자
    def print_pages(cls, *pages): # *-> 가변 위치 인자(list 활용 가능)
        # 클래스 객체 이용
        print(cls.book_title)
        pages = list(pages)
        # 페이지 순으로 정렬해서 출력
        for page in sorted(pages, key=attrgetter('num')):
            print(page.output())

-------------------------------

# 추상클래스
    # 구체적인 구현은 되어있지 않음.
    # 이름만 정의되어있음.
    # 정의만 되어있는 것이 한 개라도 존재하면 추상클래스라고 한다.


# 구현을 상속받아서 쓰는 섭클래스를 해주어야 한다.

# 인터페이스(파이썬에서는 존재하지 않음)
    # 모든 것이 다 정의만 되어있고 구체적인 구현은 섭클래스에서 해야하면 인터페이스.

-------------------------------

import sys

if __name__ == "__main__":
    #인수얻기 실인수 argument 얻기

    파이썬이실행시킨파일, book, page, content = sys.argv
    # pp(전체인수)
import datetime
object.__loader__()
__doc__=
"""
메인파일입니다.
"""

    print(__name__)
    print(globals())
    print("===============")
    print(locals())

------------------------------

# 임포트한 모듈에서의 값은 모듈 이름이 됨

