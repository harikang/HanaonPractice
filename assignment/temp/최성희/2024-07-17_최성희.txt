# 찾기 힘들 때 spotlight 써서 검색하기

--------------------------------------

python -m pip.py
pip install pandas
!python3 -m unittest.py test_hello

--------------------------------------

# 들여쓰기:space bar(space 2칸) -> tap key(space 4칸)
# 문법. 들여쓰지 않으면 syntaxerror가 발생.

---------------------------------------

# 들여쓰기:space bar(space 2칸) -> tap key(space 4칸)
      # 문법. 들여쓰지 않으면 syntaxerror가 발생.
      # 3.132.23212 버전 표기
      major = sys.version_info.major #지금 쓰고 있는 파이썬의 버전 출력
      minor = sys.version_info.minor
      # 버전에는 버전 표기법이 존재. major, minor
      pp(major)
      pp(minor)

--------------------------------------------

 ... #ellipsis 넘치는 텍스트를 말줄임표로 생략

-----------------------------------------

def asdf(self):
    pass #패스처리를 해두면 에러가 나지 않음

-----------------------------------------

    Sec03_01.asdf()  # 변수, 메모리. 메소드이자 함수. 괄호가 있으면 함수 호출의 의미
    print(Sec03_01.asdf)  # 함수 메소드인 경우 () 떼어나고 출력 시, 할당된 메모리 주소의 시작 위치를 알 수 있음.
    print(id(Sec03_01.asdf))  # 괄호 안의 객체가 할당받은 아이디를 알 수 있음. 고유값을 알 수 있음.

-----------------------------------------

# 양쪽 모두 숫자값 타입으로 연산함
# = 상황에 따라 다르게 쓰임
# + 연산자는 좌항 우항 2개가 필요한 이항연산자. 타입 확인
i + int(s)

# 양쪽 모두 숫자값 타입으로 연산함
# + 연산자는 좌항 우항 2개가 필요한 이항연산자. 타입 확인. str + str 적용되는 연산자.
str(i) + s

---------------------------------------

# 제어문
    # 분기문
        # 조건문 if
    # 반복문: for, while, #foreach, #for in, #loop ...
    # 점프문: continue, break ...

--------------------------------------

예제)

exam.py

def 성적처리(숫자성적):
    if ( 90 < 숫자성적) and (숫자성적 <= 100 ):
        성적등급 = 'A'
    elif (80 < 숫자성적) and (숫자성적 <= 90):
        성적등급 = 'B'
    elif (70 < 숫자성적) and (숫자성적 <= 80):
        성적등급 = 'C'
    elif (60 < 숫자성적) and (숫자성적 <= 70):
        성적등급 = 'D'
    elif (0 <= 숫자성적) and (숫자성적 <= 60):
        성적등급 = 'F'
    else:
        print("다시 입력하세요")
        return 성적처리



main.py

from example01.exam import 성적처리

if __name__ == "__main__":
    print("성적을 입력하세요")
    사용자입력값 = input("성적입력: ")
    결과 = 성적처리(int(사용자입력값))
    print(f"당신의 성적 등급은 {결과}입니다.")

---------------------------------------

           # 0     # 1
과일바구니 = ["사과", "배"] 2

len() # 카운트블객체(이터러블객체)를 넣으면 사람이 카운트하는 숫자로 return
# 컴퓨터는 0~~
# 사람이 카운트? 컴퓨터가 카운트?

# 자동으로 뒤에 오는 숫자에 1을 빼줌

                        # 2
for i in range(0, len(과일바구니)):
if True:

------------------------------------

# 컨테이너 객체 [[][][]]

------------------------------------

    # = 대입 연산자. 오른쪽에서 왼쪽으로.
    # == 같다. (완전히 같지 않은 타입도 있다)
    # != 같지 않다.
    # === 타입까지 같다.

-------------------------------------

x is None  # 같은 객체이면 True

# 1항 연산자: not, +, -
# 2항 연산자: +, -, *, /
# 3항 연산자:

# not은 1항 연산자
    not True # == false 1항 연산자
# 3항 연산자: ? :  if문 축약 -> *?*:* 항이 3개 들어감
    a==b ? True () : False ()

--------------------------------------

#튜플, 세트
#딕셔너리 = { "key" : "value" } 콜론으로 구분

[1,2,3,4,5] 원소element(아이템item)

items = []

# 아이템: key와 value를 같이 부름
# 리스트: 원소가 중복 가능. 길이 가변적. 추가/삭제가 가능하다.
# 배열array: 만들 때 길이가 고정 되어있음.
# 인덱스: 숫자로 가져옴.(0,1,2,3,4 ...)

--------------------------------------

#파이써닉: 가독성도 좋고 속도도 다른 구현보다 빠르게

--------------------------------------

증감 연산자: ++, --
복합대입연산자: +=, -=, *=

-------------------------------------

++, -- 증감 연산자
복합대입연산자

#C언어
for (int i=0; i<길이; i++){
    print()
}

foreach 복수 as 단수{
}

forin 단수 in 복수{
}

-----------------------------------------

과일들 = ["사과" , "배"]
for 과일 in 과일들:
    print(f'과일 이름은 값은 {item}입니다.')
    print(f'{}번째 과일은 {item}입니다.')

for i in range(0, len(과일들[i])):
    print(f'과일 이름은 값은 {과일들[i]}입니다.')
    print(f'{i}번째 과일은 {item}입니다.')

                   # (튜플)
for idx, 과일 in enumertate(과일들):
    print(f'과일 이름은 값은 {과일}입니다.')
    print(f'{idx+1}번째 과일은 {item}입니다.')    #가장 추천 방식

------------------------------------

# 홀수가 없을 때의 메시지 표시
nums = [2, 4, 6, 8]
for n in nums:
    # 짝수이면
    if n % 2 == 0:
    # 홀수이면
    if n % 2 == 1:
        break

    if n%2 in [1,3,5,7,9]:
else:
    print('홀수를 포함시켜 주세요')

------------------------------------

#스코프 = 범위
#전역 스코프 global scope = 가장 바깥
#지역 스코프 local scope =

items = ["","",""]
for i in items:
    for j in items:


----------------------------------

# 0부터 100까지
n = 0
while n <= 100:
    print(f'변수 n의 값은 {n}')
    n += 1
else:
    print('종료')

# 짝수만 출력
n = 0
while n <= 100:
    print(f'변수 n의 값은 {n}')
    n += 2
else:
    print('종료')

# 구구단
n = 2
while n < 10:
    print(n, '단', end=" ")
    n = n + 1
print()

for i in range(1, 10):
    n = 2
    while n < 10:
        print(n, "*", i, "=", (n * i), " ", end=" ")
        n = n + 1
    print()

--------------------------------

for i in range(0, 8):  # 단
    print("".center())
    for j in range(0, 9):  # 곱해지는 수
        # print(f"{i + 2} * {j + 1} = {(i + 2) * (j + 1)}")
        # print("{} * {} = {}", format(i+2, j+1, (i+2)*(j+1))
        # print("%d, %d, %d" i+2, j+1, (i+2)*(j+1)")
        print("{} * {} = {0:>2}".format(i+2, j+1, (i+2)*(j+1))

--------------------------------

# break: 현반복의 끝으로 빠져나간다. (다중 반복문에서는 바로 윗단계로 빠져나감.)
# continue: 만나는 즉시 다음 차례로 간다. continue 하단을 passing
# return: 만나는 즉시 종료
우

    # 파괴적
    # 비파괴적
    # 샬로카피
    # 딥카피

-----------------------------------

    # 시그니처
    # 익스프레션
    # 스테이트먼트

-----------------------------------

# 에러가 나면 어떻게 처리하는가?
# 예외 처리

# 파이썬이 미리 다 준비해둠

if
else if
else

try:
    import asdfasdf

except Exception as e:
    print(e)

-------------------------------------









