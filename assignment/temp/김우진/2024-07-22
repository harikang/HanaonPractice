## â€˜@â€™

In python, decorator.

In Java, annotation.

informs to interpreter or compiler

- function decorator
    
    ```python
    @function_decorator
    def asdf(a):
    	return a
    ```
    
- class decorator : decorate method of class
    
    ```python
    class classname:
    	@class_decoraotr
    	def __
    ```
    
    - @property, @field.setter
- system decorator
- user defined decorator

### @property, @field.setter

in class, there has value, function.

value â†’ must not be changed.

in java Access restricted element do.

in python we need to make it by self.

```python
if __name__ == "__main__":
    # instantiate
    robot1 = Robot("black", "ver1")
    robot2 = Robot("red", "ver2")
    robot1.color = "red" # you shouldn't change ..!
    pp(robot1.name)
    pp(robot1.color)
    pp(robot1.run())
```

there has two way 

1. Access modifier
2. @getter, @setter (Java) = @property, @field.setter (Python)
    
    ```python
    if __name__ == "__main__":
        # instantiate
        robot1 = Robot("black", "ver1")
        robot2 = Robot("red", "ver2")
        robot1.color = "red" # you shouldn't change ..!
        # setter
        robot1.change_color("red") # you should access by method
        pp(robot1.name)
        pp(robot1.color)
        pp(robot1.run())
    ```
    
    lombok : framework to make getter, setter automatically.
    

<aside>
ğŸ’¡ object-oriented programming

- encapsulation
    - Access modifier
        - JAVA
            - public
            - protected
            - default(self)
            - private
        - PYTHON
            - has no access modifier â€¦
            - everyone is â€˜publicâ€™
            - add an underscope in front of name of method or variable. but it is not really private. still accessible.
            - So, we need to make user define decorator.
</aside>

```python
# user define decorator
def trace(f):
	def wrapper():
		print(f, __name__, "call function")
		f()
		print("start function")
		
	return wrapper

@trace
def hello():
	print("hello")
```

method overloading

- using same named method, if methodâ€™s name is same, if return is different, we can use both.

method overwriting

- re-define method defined by parent

book.py

```python
class Book:
    def __init__(self, title, raw_price):
        if raw_price < 0:
            raise ValueError('price must be positive')
        self.title = title
        self.raw_price = raw_price
        self._discounts = 0
    @property
    def discounts(self):
        return self._discounts
    @discounts.setter
    def discounts(self, value):
        if value < 0 or 100 < value:
            raise ValueError(
                'discounts must be between 0 and 100')
        self._discounts = value
    @property
    def price(self):
        multi = 100 - self._discounts
        return int(self.raw_price * multi / 100)
```

main.py

```python
from sec06.book import Book
from helpers.debug import *

if __name__ == "__main__":
    book1 = Book("title", 14000)
    print(book1.discounts)
    print(book1.price)
    book1._discounts = 1000
    print(book1.discounts)
    print(book1.price)
```

attribute start with undercope : can access

attribute start with dunder

- **__init**__(self, )
- __new__()

## Declaration vs Definition

dynamic programming langauge (Python)

- you donâ€™t need to declare variables, functions, classes, or data types ahead of time.
- you typically donâ€™t think in terms of â€˜declarationâ€™ vs â€˜definitionâ€™
- you just define your variables, functions, and classes as needed

statically typed language (C/C++, Java, C# â€¦ )

```c
int my_var;  // Declaration
my_var = 10; // Definition

void my_func(); // Declaration
void my_func() { // Definition
    // function body
}
```

```java
int myVar; // Declaration
myVar = 10; // Definition

void myFunc(); // Declaration
void myFunc() { // Definition
    // method body
}
```

```csharp
int myVar; // Declaration
myVar = 10; // Definition

void MyFunc(); // Declaration
void MyFunc() { // Definition
    // method body
}
```

## class variable

```python
# í´ë˜ìŠ¤ ë³€ìˆ˜ë¥¼ ê°€ì§„ í´ë˜ìŠ¤ ì •ì˜
class Page:
    book_title = 'Python Practice Book'
    
Page.book_title  # ì¸ìŠ¤í„´ìŠ¤ê°€ ì—†ì–´ë„ ì°¸ì¡°í•  ìˆ˜ ìˆìŒ

Page.book_title = 'No title'  # í´ë˜ìŠ¤ ë³€ìˆ˜ aì—…ë°ì´íŠ¸
Page.book_title

first_page = Page()
second_page = Page()
# í´ë˜ìŠ¤ ë³€ìˆ˜ëŠ” ì¸ìŠ¤í„´ìŠ¤ì—ì„œë„ ì°¸ì¡° ê°€ëŠ¥
first_page.book_title

# í´ë˜ìŠ¤ ë³€ìˆ˜ ì—…ë°ì´íŠ¸
Page.book_title = 'Python Practice Book'

# í´ë˜ìŠ¤ ë³€ìˆ˜ëŠ” ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ê³µìœ ë¨
first_page.book_title

# ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ ì‚­ì œ
del first_page.book_title

# ì¸ìŠ¤í„´ìŠ¤ ì†ì„±ì´ ì•„ë‹ˆë¯€ë¡œ, í´ë˜ìŠ¤ ì†ì„±ì´ ê²€ìƒ‰ë¨
first_page.book_title
```

## class method

```python
# ì†ì„±ì„ ì´ìš©í•œ ì •ë ¬ì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„í¬íŠ¸
from operator import attrgetter

class Page:
    book_title = 'Python Practice Book'
    def __init__(self, num, content): # initialize
        self.num = num # instance variable
        self.content = content
    def output(self): # instance method
        return f'{self.content}'
    # í´ë˜ìŠ¤ ë©”ì„œë“œì˜ ì²« ë²ˆì§¸ ì¸ìˆ˜ëŠ” í´ë˜ìŠ¤ ê°ì²´
    @classmethod # inform to interpreter thhat this is classmethod.
    def print_pages(cls, *pages):
        # í´ë˜ìŠ¤ ê°ì²´ ì´ìš©
        print(cls.book_title)
        pages = list(pages)
        # í˜ì´ì§€ ìˆœìœ¼ë¡œ ì •ë ¬í•´ì„œ ì¶œë ¥
        for page in sorted(pages, key=attrgetter('num')):
            print(page.output())
            
first = Page(1, 'first page')
second = Page(2, 'second page')
third = Page(3, 'third page')

# í´ë˜ìŠ¤ ë©”ì„œë“œ í˜¸ì¶œ
Page.print_pages(first, third, second)
```

## static method

= utility method. donâ€™t need to instantiate

```python
class Page:
    def __init__(self, num, content):
        self.num = num
        self.content = content
    @staticmethod  # ìŠ¤íƒœí‹± ë©”ì„œë“œë¡œ ì •ì˜
    def check_blank(page):
        return bool(page.content)
        
page = Page(1, '')
Page.check_blank(page)

def check_blank(page):  # í•¨ìˆ˜ë¡œ ë¬¸ì œ ì—†ìŒ
    return bool(page.content)
    
check_blank(page)
```

if i want to make code with all class, not function. i can use staticmethod.

Even if there is no relationship between that method and class, you can write that method in class. because it semems to be clear.

## class heritage

```python
class Page:
    def __init__(self, num, content):
        self.num = num
        self.content = content
    def output(self):
        return f'{self.content}'
        
        
# ë©”ì„œë“œ ì˜¤ë²„ë¼ì´ë“œ 
class TitlePage(Page):
    def output(self):
        # ë² ì´ìŠ¤ í´ë˜ìŠ¤ì˜ ë©”ì„œë“œëŠ” ìë™ìœ¼ë¡œ í˜¸ì¶œë˜ì§€ ì•Šìœ¼ë¯€ë¡œ
        # ëª…ì‹œì ìœ¼ë¡œ í˜¸ì¶œí•¨
        title = super().output()
        return title.upper()
```

## every object is sub class of â€˜objectâ€™ class.

## abstract class vs interface

- abstract class
    - Must be implemented in a subclass that inherits and uses
    - only define name.

# 7. module

module = .py file

```python
>>> import b64
>>> b64.str_to_base64('ham')  # ì§€ê¸ˆì€ ì—ëŸ¬
>>> b64.base64_to_str(b'aGFt')  # ì§€ê¸ˆì€ ì—ëŸ¬
>>> import b64
>>> dir(b64)  # str_to_base64ì™€ base64_to_strì€ ì•„ì§ ì—†ìŒ
['__builtins__', ... '__name__', '__package__', '__path__', '__spec__']
(ì£¼:b64/__init__.py)
from .encoder import str_to_base64
from .decoder import base64_to_str
```

```python
>>> dir()  # ì„í¬íŠ¸ ì „ ìƒíƒœ
['__annotations__', ... '__package__', '__spec__']

>>> from b64.decoder import *
>>> dir()  # base64_to_str ì´ì™¸ì˜ base64ë„ í¬í•¨ë¨
['__annotations__', ... '__package__', '__spec__', 'base64', 'base64_to_str']
```

```python
from gzip import open  # gzipì˜ openì„ ì„í¬íŠ¸
open  # open()ì€ gzip.open()ìœ¼ë¡œ ì§€ì •ë˜ì–´ ìˆìŒ
```